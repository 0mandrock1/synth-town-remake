<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Synth Town</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    /* === RESET === */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; font-family: 'Inter', sans-serif; }

    /* === LAYOUT === */
    #app {
      display: grid;
      grid-template-areas:
        "toolbar main properties"
        "transport transport transport";
      grid-template-columns: 200px 1fr 0px;
      grid-template-rows: 1fr 64px;
      height: 100vh;
      background: #0a0a12;
      color: #e0e0e0;
    }

    /* === TOOLBAR === */
    #toolbar {
      grid-area: toolbar;
      background: #12122a;
      border-right: 1px solid rgba(255,255,255,0.1);
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 3px;
      overflow-y: auto;
    }
    .st-toolbar-section {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: rgba(255,255,255,0.3);
      margin: 8px 4px 4px;
    }
    .st-tool-btn {
      background: transparent;
      color: #e0e0e0;
      border: 1px solid rgba(255,255,255,0.1);
      padding: 7px 10px;
      text-align: left;
      cursor: pointer;
      border-radius: 4px;
      font-size: 12px;
      font-family: inherit;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .st-tool-btn:hover { background: rgba(255,255,255,0.06); }
    .st-tool-btn.st-active { background: rgba(100,181,246,0.15); border-color: #64b5f6; color: #64b5f6; }
    .st-color-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    /* === MAIN CANVAS === */
    main {
      grid-area: main;
      overflow: auto;
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
    }
    #game { display: block; cursor: crosshair; }

    /* === PROPERTY PANEL === */
    #properties {
      grid-area: properties;
      background: #12122a;
      border-left: 1px solid rgba(255,255,255,0.1);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .st-props-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px;
      border-bottom: 1px solid rgba(255,255,255,0.08);
    }
    .st-props-title { font-size: 13px; font-weight: 600; flex: 1; }
    .st-props-close {
      background: none;
      border: none;
      color: rgba(255,255,255,0.4);
      cursor: pointer;
      font-size: 16px;
      padding: 2px 6px;
      border-radius: 3px;
    }
    .st-props-close:hover { color: #e0e0e0; background: rgba(255,255,255,0.08); }
    .st-props-body { padding: 12px; display: flex; flex-direction: column; gap: 12px; }
    .st-props-row { display: flex; flex-direction: column; gap: 4px; }
    .st-props-label { font-size: 10px; text-transform: uppercase; letter-spacing: 0.08em; color: rgba(255,255,255,0.4); }
    .st-props-value { font-size: 12px; color: #e0e0e0; }
    .st-props-row input[type="range"] { width: 100%; accent-color: #64b5f6; cursor: pointer; }

    /* === TRANSPORT BAR === */
    #transport {
      grid-area: transport;
      background: #12122a;
      border-top: 1px solid rgba(255,255,255,0.1);
      display: flex;
      align-items: center;
      padding: 0 16px;
      gap: 12px;
    }
    #btn-play {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #64b5f6;
      color: #0a0a12;
      border: none;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #btn-play:hover { background: #90caf9; }
    #btn-play.st-active { background: #ef5350; }
    .st-transport-label { font-size: 11px; color: rgba(255,255,255,0.4); white-space: nowrap; }
    #slider-bpm { width: 120px; cursor: pointer; accent-color: #64b5f6; }
    #bpm-display { font-size: 13px; color: #64b5f6; font-weight: 600; min-width: 36px; }
    #status-display { font-size: 11px; color: rgba(255,255,255,0.3); }
    #fps-display { font-size: 11px; color: rgba(255,255,255,0.3); margin-left: auto; }

    /* === MODALS & OVERLAYS === */
    #audio-overlay {
      position: fixed;
      inset: 0;
      background: rgba(10,10,18,0.95);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      gap: 16px;
    }
    #audio-overlay h2 { font-size: 24px; color: #64b5f6; }
    #audio-overlay p { font-size: 14px; color: rgba(255,255,255,0.4); }
    #btn-start-audio {
      background: #64b5f6;
      color: #0a0a12;
      border: none;
      padding: 12px 32px;
      font-size: 16px;
      font-weight: 600;
      border-radius: 6px;
      cursor: pointer;
    }
    #btn-start-audio:hover { background: #90caf9; }

    /* === PIANO PICKER === */
    .st-piano-wrap { display: flex; flex-direction: column; gap: 6px; }
    .st-piano-nav {
      display: flex; align-items: center; justify-content: space-between; gap: 4px;
    }
    .st-piano-oct-label { font-size: 12px; color: #e0e0e0; text-align: center; min-width: 32px; }
    .st-oct-btn {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.1);
      color: #e0e0e0; cursor: pointer; border-radius: 3px;
      width: 24px; height: 22px; font-size: 14px; font-family: inherit;
      display: flex; align-items: center; justify-content: center; padding: 0;
    }
    .st-oct-btn:hover { background: rgba(255,255,255,0.15); }
    .st-piano-keys { position: relative; height: 60px; width: 196px; }
    .st-white-key {
      position: absolute; top: 0; width: 28px; height: 60px;
      background: #d8d8d8; border-right: 1px solid #555; border-bottom: 1px solid #555;
      border-radius: 0 0 3px 3px; cursor: pointer; box-sizing: border-box;
    }
    .st-white-key:hover { background: #fff; }
    .st-black-key {
      position: absolute; top: 0; width: 18px; height: 36px;
      background: #1a1a2e; border: 1px solid #444;
      border-radius: 0 0 3px 3px; cursor: pointer; box-sizing: border-box; z-index: 2;
    }
    .st-black-key:hover { background: #2e2e5e; }

    /* === LOCKED TOOL === */
    .st-tool-btn.st-locked { opacity: 0.32; cursor: not-allowed; pointer-events: none; }

    /* === UNLOCK TOAST === */
    .st-unlock-toast {
      position: fixed; bottom: 80px; left: 50%;
      transform: translateX(-50%) translateY(10px);
      background: #1a3a1a; border: 1px solid #66bb6a; color: #66bb6a;
      padding: 8px 20px; border-radius: 6px; font-size: 13px; z-index: 50;
      animation: st-toast-fade 3s forwards;
    }
    @keyframes st-toast-fade {
      0%   { opacity: 0; transform: translateX(-50%) translateY(10px); }
      15%  { opacity: 1; transform: translateX(-50%) translateY(0); }
      80%  { opacity: 1; }
      100% { opacity: 0; }
    }

    /* === SCORE === */
    #score-display { font-size: 12px; color: #ffa726; font-weight: 500; }
  </style>
</head>
<body>

  <div id="audio-overlay">
    <h2>Synth Town</h2>
    <p>A city that plays music</p>
    <button id="btn-start-audio">Start Audio</button>
  </div>

  <div id="app">
    <aside id="toolbar"></aside>
    <main><canvas id="game"></canvas></main>
    <aside id="properties"></aside>
    <footer id="transport">
      <button id="btn-play">&#9654;</button>
      <span class="st-transport-label">BPM</span>
      <input id="slider-bpm" type="range" min="60" max="180" value="120">
      <span id="bpm-display">120</span>
      <span id="status-display"></span>
      <span id="score-display"></span>
      <span id="fps-display"></span>
    </footer>
  </div>

  <script>
  'use strict';
  const ST = {};

  // ============================================================
  // 1. ST.Config
  // ============================================================
  ST.Config = (function() {
    console.log('[Config] initialized');
    return {
      TILE: 32,
      GRID_W: 20,
      GRID_H: 15,
      BPM_DEFAULT: 120,
      BPM_MIN: 60,
      BPM_MAX: 180,
      MAX_VEHICLES: 8,
      MAX_VOICES: 8,
      MAX_BUILDINGS: 50,
      MAX_ROADS: 200,
      DEV: false,
      COLORS: {
        bg: '#0a0a12',
        grid: 'rgba(255,255,255,0.05)',
        road: '#1a1a2e',
        roadLine: 'rgba(255,255,255,0.4)',
        ui: '#12122a',
        border: 'rgba(255,255,255,0.1)',
        text: '#e0e0e0',
        accent: '#64b5f6'
      }
    };
  })();

  // ============================================================
  // 2. ST.Audio
  // ============================================================
  ST.Audio = (function() {
    console.log('[Audio] initialized');

    let _ctx = null;
    let _masterGain = null;
    let _bpm = ST.Config.BPM_DEFAULT;

    function _connectWithFilter(osc, env, filterType, filterCutoff) {
      if (filterType && filterCutoff) {
        const filter = _ctx.createBiquadFilter();
        filter.type = filterType;
        filter.frequency.value = filterCutoff;
        osc.connect(filter);
        filter.connect(env);
      } else {
        osc.connect(env);
      }
    }

    function _addSends(env, sendDelay, sendReverb) {
      if (sendDelay > 0 && ST.Effects && ST.Effects.getDelayInput()) {
        const ds = _ctx.createGain();
        ds.gain.value = sendDelay;
        env.connect(ds);
        ds.connect(ST.Effects.getDelayInput());
      }
      if (sendReverb > 0 && ST.Effects && ST.Effects.getReverbInput()) {
        const rs = _ctx.createGain();
        rs.gain.value = sendReverb;
        env.connect(rs);
        rs.connect(ST.Effects.getReverbInput());
      }
    }

    return {
      onTrigger: null,

      init: function() {
        if (_ctx) return;
        _ctx = new (window.AudioContext || window.webkitAudioContext)();
        _masterGain = _ctx.createGain();
        _masterGain.gain.value = 0.8;
        _masterGain.connect(_ctx.destination);
        console.log('[Audio] AudioContext created, state:', _ctx.state);
      },

      trigger: function(params) {
        if (!_ctx || _ctx.state === 'suspended') return;
        const waveform     = params.waveform     || 'sine';
        const pitch        = params.pitch        || 440;
        const decay        = params.decay        || 0.5;
        const velocity     = params.velocity     !== undefined ? params.velocity  : 1.0;
        const attack       = params.attack       || 0;
        const filterType   = params.filterType   || null;
        const filterCutoff = params.filterCutoff || null;
        const sendDelay    = params.sendDelay    !== undefined
          ? params.sendDelay  : (ST.Effects ? ST.Effects.getSendDelay()  : 0);
        const sendReverb   = params.sendReverb   !== undefined
          ? params.sendReverb : (ST.Effects ? ST.Effects.getSendReverb() : 0);
        const now = _ctx.currentTime;

        const osc = _ctx.createOscillator();
        const env = _ctx.createGain();
        osc.type = waveform;
        osc.frequency.value = pitch;

        if (attack > 0) {
          env.gain.setValueAtTime(0.001, now);
          env.gain.linearRampToValueAtTime(0.4 * velocity, now + attack);
        } else {
          env.gain.setValueAtTime(0.4 * velocity, now);
        }
        env.gain.exponentialRampToValueAtTime(0.001, now + attack + decay);

        _connectWithFilter(osc, env, filterType, filterCutoff);
        env.connect(_masterGain);
        _addSends(env, sendDelay, sendReverb);

        osc.start(now);
        osc.stop(now + attack + decay + 0.05);

        if (typeof ST.Audio.onTrigger === 'function') ST.Audio.onTrigger(params);
        if (ST.Config.DEV) console.log('[Audio] trigger:', waveform, pitch);
      },

      setBPM: function(bpm) {
        _bpm = Math.max(ST.Config.BPM_MIN, Math.min(ST.Config.BPM_MAX, bpm));
      },

      getBPM:      function() { return _bpm; },
      isReady:     function() { return _ctx !== null && _ctx.state !== 'suspended'; },
      getContext:  function() { return _ctx; },
      getMasterGain: function() { return _masterGain; }
    };
  })();

  // ============================================================
  // 3. ST.Grid
  // ============================================================
  ST.Grid = (function() {
    console.log('[Grid] initialized');

    let _tiles = null;

    function _makeTile() {
      return { type: 'empty', roadDir: null, building: null, sign: null };
    }

    return {
      init: function() {
        _tiles = [];
        for (let y = 0; y < ST.Config.GRID_H; y++) {
          _tiles[y] = [];
          for (let x = 0; x < ST.Config.GRID_W; x++) {
            _tiles[y][x] = _makeTile();
          }
        }
      },

      getTile: function(x, y) {
        if (!this.isInBounds(x, y)) return null;
        return _tiles[y][x];
      },

      setTile: function(x, y, data) {
        if (!this.isInBounds(x, y)) return;
        Object.assign(_tiles[y][x], data);
      },

      getNeighbors: function(x, y) {
        const DIRS = [
          { dx: 0, dy: -1, dir: 'N' },
          { dx: 0, dy: 1,  dir: 'S' },
          { dx: 1, dy: 0,  dir: 'E' },
          { dx: -1, dy: 0, dir: 'W' }
        ];
        const result = [];
        DIRS.forEach(function(d) {
          const nx = x + d.dx;
          const ny = y + d.dy;
          if (ST.Grid.isInBounds(nx, ny)) {
            result.push({ tile: _tiles[ny][nx], x: nx, y: ny, dir: d.dir });
          }
        });
        return result;
      },

      isInBounds: function(x, y) {
        return x >= 0 && x < ST.Config.GRID_W && y >= 0 && y < ST.Config.GRID_H;
      },

      forEachTile: function(callback) {
        for (let y = 0; y < ST.Config.GRID_H; y++) {
          for (let x = 0; x < ST.Config.GRID_W; x++) {
            callback(_tiles[y][x], x, y);
          }
        }
      }
    };
  })();

  // ============================================================
  // 4. ST.Buildings
  // ============================================================
  ST.Buildings = (function() {
    console.log('[Buildings] initialized');

    const TYPES = {
      sine:     { waveform: 'sine',     color: '#64b5f6', decay: 1.2,  pitchDefault: 261.63, widthRatio: 0.80, minH: 0.4, maxH: 1.5 },
      square:   { waveform: 'square',   color: '#ef5350', decay: 0.3,  pitchDefault: 196.00, widthRatio: 0.90, minH: 0.3, maxH: 1.2 },
      triangle: { waveform: 'triangle', color: '#66bb6a', decay: 0.8,  pitchDefault: 329.63, widthRatio: 0.60, minH: 0.6, maxH: 2.0 },
      sawtooth: { waveform: 'sawtooth', color: '#ffa726', decay: 0.5,  pitchDefault: 220.00, widthRatio: 0.90, minH: 0.4, maxH: 1.4 },
      pulse:    { waveform: 'square',   color: '#ab47bc', decay: 0.15, pitchDefault: 523.25, widthRatio: 0.30, minH: 0.8, maxH: 2.5 }
    };

    const _buildings = [];

    function _drawSine(ctx, bx, by, bw, color) {
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(bx + bw / 2, by, bw / 2, Math.PI, 0);
      ctx.fill();
    }

    function _drawSquare(ctx, bx, by, bw, color) {
      ctx.fillStyle = color;
      const chimneyW = Math.max(3, Math.round(bw * 0.15));
      ctx.fillRect(bx + bw * 0.65, by - 7, chimneyW, 7);
    }

    function _drawTriangle(ctx, bx, by, bw, bh, color) {
      ctx.fillStyle = color;
      const spikeH = Math.round(bh * 0.55);
      ctx.beginPath();
      ctx.moveTo(bx, by);
      ctx.lineTo(bx + bw / 2, by - spikeH);
      ctx.lineTo(bx + bw, by);
      ctx.fill();
    }

    function _drawSawtooth(ctx, bx, by, bw, color) {
      ctx.fillStyle = color;
      const stepW = Math.round(bw / 3);
      ctx.fillRect(bx,             by - 7, stepW, 7);
      ctx.fillRect(bx + stepW,     by - 4, stepW, 4);
      ctx.fillRect(bx + stepW * 2, by - 2, stepW, 2);
    }

    function _drawPulse(ctx, bx, by, bw, color) {
      const cx = bx + bw / 2;
      ctx.strokeStyle = color;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(cx, by);
      ctx.lineTo(cx, by - 12);
      ctx.stroke();
      ctx.lineWidth = 1;
      ctx.fillStyle = 'rgba(171,71,188,0.5)';
      ctx.beginPath();
      ctx.arc(cx, by - 12, 2.5, 0, Math.PI * 2);
      ctx.fill();
    }

    return {
      TYPES: TYPES,

      create: function(type, x, y) {
        const tile = ST.Grid.getTile(x, y);
        if (!tile || tile.type !== 'empty') return null;
        if (_buildings.length >= ST.Config.MAX_BUILDINGS) return null;
        const def = TYPES[type];
        if (!def) return null;
        const building = {
          type: type, x: x, y: y,
          waveform: def.waveform, color: def.color,
          pitch: def.pitchDefault, decay: def.decay, level: 1, flash: 0
        };
        _buildings.push(building);
        ST.Grid.setTile(x, y, { type: 'building', building: building });
        return building;
      },

      remove: function(x, y) {
        const tile = ST.Grid.getTile(x, y);
        if (!tile || tile.type !== 'building') return;
        const idx = _buildings.indexOf(tile.building);
        if (idx !== -1) _buildings.splice(idx, 1);
        ST.Grid.setTile(x, y, { type: 'empty', building: null });
      },

      draw: function(ctx, b) {
        const { TILE } = ST.Config;
        const def = TYPES[b.type];
        if (!def) return;
        const t  = (b.level - 1) / 7;
        const bw = Math.round(def.widthRatio * TILE);
        const bh = Math.round((def.minH + t * (def.maxH - def.minH)) * TILE);
        const bx = b.x * TILE + Math.round((TILE - bw) / 2);
        const by = b.y * TILE + TILE - 2;

        if (b.flash > 0) {
          ctx.save();
          ctx.shadowColor = b.color;
          ctx.shadowBlur  = 4 + b.flash * 16;
        }

        ctx.fillStyle = b.color;
        ctx.fillRect(bx, by - bh, bw, bh);

        if (b.type === 'sine')     _drawSine(ctx, bx, by - bh, bw, b.color);
        if (b.type === 'square')   _drawSquare(ctx, bx, by - bh, bw, b.color);
        if (b.type === 'triangle') _drawTriangle(ctx, bx, by - bh, bw, bh, b.color);
        if (b.type === 'sawtooth') _drawSawtooth(ctx, bx, by - bh, bw, b.color);
        if (b.type === 'pulse')    _drawPulse(ctx, bx, by - bh, bw, b.color);

        if (b.flash > 0) ctx.restore();
      },

      getAt: function(x, y) {
        const tile = ST.Grid.getTile(x, y);
        if (!tile || tile.type !== 'building') return null;
        return tile.building;
      },

      getProperties: function(b) {
        return { pitch: b.pitch, decay: b.decay, waveform: b.waveform, color: b.color, level: b.level };
      },

      setProperty: function(b, key, val) { b[key] = val; },

      count:  function() { return _buildings.length; },
      getAll: function() { return _buildings.slice(); }
    };
  })();

  // ============================================================
  // 5. ST.Roads
  // ============================================================
  ST.Roads = (function() {
    console.log('[Roads] initialized');

    const DIR_DELTA = { N:{dx:0,dy:-1}, S:{dx:0,dy:1}, E:{dx:1,dy:0}, W:{dx:-1,dy:0} };
    let _count = 0;

    function _recalcDir(x, y) {
      const tile = ST.Grid.getTile(x, y);
      if (!tile || tile.type !== 'road') return;
      let dir = '';
      ST.Grid.getNeighbors(x, y).forEach(function(nb) {
        if (nb.tile.type === 'road') dir += nb.dir;
      });
      ST.Grid.setTile(x, y, { roadDir: dir });
    }

    return {
      place: function(x, y) {
        const tile = ST.Grid.getTile(x, y);
        if (!tile || tile.type !== 'empty') return false;
        if (_count >= ST.Config.MAX_ROADS) return false;
        ST.Grid.setTile(x, y, { type: 'road', roadDir: '' });
        _count++;
        this.autoConnect(x, y);
        return true;
      },

      remove: function(x, y) {
        const tile = ST.Grid.getTile(x, y);
        if (!tile || tile.type !== 'road') return;
        ST.Grid.setTile(x, y, { type: 'empty', roadDir: null, building: null, sign: null });
        _count--;
        ST.Grid.getNeighbors(x, y).forEach(function(nb) {
          if (nb.tile.type === 'road') _recalcDir(nb.x, nb.y);
        });
      },

      autoConnect: function(x, y) {
        _recalcDir(x, y);
        ST.Grid.getNeighbors(x, y).forEach(function(nb) {
          if (nb.tile.type === 'road') _recalcDir(nb.x, nb.y);
        });
      },

      getNextTile: function(x, y, dir) {
        const d = DIR_DELTA[dir];
        if (!d) return null;
        const nx = x + d.dx;
        const ny = y + d.dy;
        const tile = ST.Grid.getTile(nx, ny);
        if (!tile || tile.type !== 'road') return null;
        return { x: nx, y: ny, dir: dir };
      },

      draw: function(ctx, x, y, tile) {
        const { TILE, COLORS } = ST.Config;
        const px = x * TILE;
        const py = y * TILE;
        ctx.fillStyle = COLORS.road;
        ctx.fillRect(px, py, TILE, TILE);

        const dir      = tile.roadDir || '';
        const hasN     = dir.includes('N');
        const hasS     = dir.includes('S');
        const hasE     = dir.includes('E');
        const hasW     = dir.includes('W');
        const isolated = !hasN && !hasS && !hasE && !hasW;
        const cx = px + TILE / 2;
        const cy = py + TILE / 2;

        ctx.strokeStyle = COLORS.roadLine;
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);

        if (hasN || hasS || isolated) {
          ctx.beginPath();
          ctx.moveTo(cx, hasN ? py : cy);
          ctx.lineTo(cx, hasS ? py + TILE : cy);
          ctx.stroke();
        }
        if (hasE || hasW || isolated) {
          ctx.beginPath();
          ctx.moveTo(hasW ? px : cx, cy);
          ctx.lineTo(hasE ? px + TILE : cx, cy);
          ctx.stroke();
        }
        ctx.setLineDash([]);
      },

      count: function() { return _count; }
    };
  })();

  // ============================================================
  // 6. ST.Vehicles
  // ============================================================
  ST.Vehicles = (function() {
    console.log('[Vehicles] initialized');

    const TYPES = {
      car:     { velocityMult: 1.00, attack: 0,     decay: 0.20, color: '#dce0e8', size: 5 },
      bicycle: { velocityMult: 0.80, attack: 0.005, decay: 0.12, color: '#64b5f6', size: 3 },
      bus:     { velocityMult: 1.20, attack: 0.010, decay: 0.45, color: '#ffa726', size: 7 }
    };

    const DIR_DELTA    = { N:{dx:0,dy:-1}, S:{dx:0,dy:1}, E:{dx:1,dy:0}, W:{dx:-1,dy:0} };
    const DIR_OPPOSITE = { N:'S', S:'N', E:'W', W:'E' };
    const DIR_ANGLE    = { E:0, S:Math.PI/2, W:Math.PI, N:-Math.PI/2 };
    const _vehicles = [];

    function _chooseDir(x, y, currentDir) {
      const tile = ST.Grid.getTile(x, y);
      if (!tile) return null;
      const roadDir = tile.roadDir || '';
      const possible = ['N','S','E','W'].filter(function(d) { return roadDir.includes(d); });
      if (possible.length === 0) return null;
      const noUTurn = possible.filter(function(d) { return d !== DIR_OPPOSITE[currentDir]; });
      const choices = noUTurn.length > 0 ? noUTurn : possible;
      return choices[Math.floor(Math.random() * choices.length)];
    }

    function _triggerNearby(vehicle) {
      const typeDef = TYPES[vehicle.type];
      ST.Grid.getNeighbors(vehicle.x, vehicle.y).forEach(function(nb) {
        if (nb.tile.type === 'building' && nb.tile.building) {
          const b = nb.tile.building;
          ST.Audio.trigger({
            waveform: b.waveform, pitch: b.pitch,
            attack: typeDef.attack, decay: typeDef.decay,
            velocity: typeDef.velocityMult
          });
          b.flash = 1.0;
          if (ST.Config.DEV) console.log('[ONBOARDING] step: trigger');
        }
      });
    }

    function _advance(vehicle) {
      const signResult = ST.Signs.evaluate(vehicle, vehicle.x, vehicle.y);
      if (signResult && signResult.action === 'stop') {
        vehicle.stopped   = true;
        vehicle.stopTimer = signResult.duration || 0.5;
        vehicle.nextX = vehicle.x;
        vehicle.nextY = vehicle.y;
        return;
      }

      const dir = (signResult && signResult.action === 'force')
        ? signResult.direction
        : _chooseDir(vehicle.x, vehicle.y, vehicle.dir);

      if (!dir) { vehicle.nextX = vehicle.x; vehicle.nextY = vehicle.y; return; }

      const d  = DIR_DELTA[dir];
      const nx = vehicle.x + d.dx;
      const ny = vehicle.y + d.dy;
      const tile = ST.Grid.getTile(nx, ny);

      if (!tile || tile.type !== 'road') {
        const rev  = DIR_OPPOSITE[dir];
        const rd   = DIR_DELTA[rev];
        const revTile = ST.Grid.getTile(vehicle.x + rd.dx, vehicle.y + rd.dy);
        if (revTile && revTile.type === 'road') {
          vehicle.dir = rev;
          vehicle.nextX = vehicle.x + rd.dx;
          vehicle.nextY = vehicle.y + rd.dy;
        } else {
          vehicle.nextX = vehicle.x;
          vehicle.nextY = vehicle.y;
        }
        return;
      }

      vehicle.dir   = dir;
      vehicle.nextX = nx;
      vehicle.nextY = ny;
    }

    return {
      TYPES: TYPES,

      spawn: function(type, x, y) {
        if (_vehicles.length >= ST.Config.MAX_VEHICLES) return null;
        const tile = ST.Grid.getTile(x, y);
        if (!tile || tile.type !== 'road') return null;
        if (!TYPES[type]) return null;

        const roadDir = tile.roadDir || '';
        const dirs = ['N','S','E','W'].filter(function(d) { return roadDir.includes(d); });
        const startDir = dirs.length > 0 ? dirs[Math.floor(Math.random() * dirs.length)] : 'E';
        const d = DIR_DELTA[startDir] || DIR_DELTA['E'];

        const vehicle = {
          type: type, x: x, y: y,
          dir: startDir, progress: 0,
          nextX: x + d.dx, nextY: y + d.dy,
          stopped: false, stopTimer: 0
        };

        const nextTile = ST.Grid.getTile(vehicle.nextX, vehicle.nextY);
        if (!nextTile || nextTile.type !== 'road') {
          vehicle.nextX = x;
          vehicle.nextY = y;
        }

        _vehicles.push(vehicle);
        return vehicle;
      },

      remove: function(vehicle) {
        const idx = _vehicles.indexOf(vehicle);
        if (idx !== -1) _vehicles.splice(idx, 1);
      },

      update: function(dt) {
        const speed = (ST.Audio.getBPM() / 120) * 2.0;

        ST.Buildings.getAll().forEach(function(b) {
          if (b.flash > 0) b.flash = Math.max(0, b.flash - dt / 0.15);
        });

        _vehicles.forEach(function(vehicle) {
          if (vehicle.stopped) {
            vehicle.stopTimer -= dt;
            if (vehicle.stopTimer <= 0) {
              vehicle.stopped = false;
              _advance(vehicle);
            }
            return;
          }

          vehicle.progress += dt * speed;

          while (vehicle.progress >= 1.0 && !vehicle.stopped) {
            vehicle.progress -= 1.0;
            vehicle.x = vehicle.nextX;
            vehicle.y = vehicle.nextY;
            _triggerNearby(vehicle);
            _advance(vehicle);
            if (vehicle.nextX === vehicle.x && vehicle.nextY === vehicle.y) {
              vehicle.progress = 0;
              break;
            }
          }
        });
      },

      draw: function(ctx) {
        const { TILE } = ST.Config;
        _vehicles.forEach(function(vehicle) {
          const typeDef = TYPES[vehicle.type];
          const dx = vehicle.nextX - vehicle.x;
          const dy = vehicle.nextY - vehicle.y;
          const px = (vehicle.x + dx * vehicle.progress) * TILE + TILE / 2;
          const py = (vehicle.y + dy * vehicle.progress) * TILE + TILE / 2;
          const s  = typeDef.size;

          ctx.save();
          ctx.translate(px, py);
          ctx.rotate(DIR_ANGLE[vehicle.dir] || 0);
          ctx.fillStyle   = typeDef.color;
          ctx.strokeStyle = 'rgba(0,0,0,0.55)';
          ctx.lineWidth   = 1;

          if (vehicle.type === 'bicycle') {
            ctx.beginPath();
            ctx.arc(0, 0, s, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
          } else {
            ctx.fillRect(-s, -s * 0.6, s * 2, s * 1.2);
            ctx.strokeRect(-s, -s * 0.6, s * 2, s * 1.2);
          }
          ctx.restore();
        });
      },

      getAll: function() { return _vehicles.slice(); },
      count:  function() { return _vehicles.length; }
    };
  })();

  // ============================================================
  // 7. ST.Signs
  // ============================================================
  ST.Signs = (function() {
    console.log('[Signs] initialized');

    const TYPES = {
      trafficLight: { period: 2.0 },
      oneWay:       { defaultDir: 'E' },
      roundabout:   {}
    };

    const DIR_CLOCKWISE = { N:'E', E:'S', S:'W', W:'N' };

    return {
      TYPES: TYPES,

      place: function(type, x, y, params) {
        const tile = ST.Grid.getTile(x, y);
        if (!tile || tile.type !== 'road') return false;
        if (!TYPES[type]) return false;
        const sign = { type: type, x: x, y: y, params: params || {} };
        ST.Grid.setTile(x, y, { sign: sign });
        return true;
      },

      remove: function(x, y) {
        ST.Grid.setTile(x, y, { sign: null });
      },

      evaluate: function(vehicle, x, y) {
        const tile = ST.Grid.getTile(x, y);
        if (!tile || !tile.sign) return null;
        const sign = tile.sign;

        if (sign.type === 'trafficLight') {
          const period = TYPES.trafficLight.period;
          const phase  = Math.floor(Date.now() / (period * 1000)) % 2;
          if (phase === 0) return { action: 'stop', duration: period };
          return null;
        }

        if (sign.type === 'oneWay') {
          const dir = (sign.params && sign.params.dir) || TYPES.oneWay.defaultDir;
          return { action: 'force', direction: dir };
        }

        if (sign.type === 'roundabout') {
          return { action: 'force', direction: DIR_CLOCKWISE[vehicle.dir] || vehicle.dir };
        }

        return null;
      },

      draw: function(ctx, x, y, sign) {
        const { TILE } = ST.Config;
        const px = x * TILE;
        const py = y * TILE;
        const cx = px + TILE / 2;
        const cy = py + TILE / 2;

        if (sign.type === 'trafficLight') {
          const isRed = Math.floor(Date.now() / (TYPES.trafficLight.period * 1000)) % 2 === 0;
          ctx.fillStyle = '#1a1a2e';
          ctx.fillRect(cx - 5, cy - TILE / 3 - 5, 10, 10);
          ctx.fillStyle = isRed ? '#ef5350' : '#66bb6a';
          ctx.beginPath();
          ctx.arc(cx, cy - TILE / 3, 3.5, 0, Math.PI * 2);
          ctx.fill();

        } else if (sign.type === 'oneWay') {
          const ARROWS = { N:'↑', S:'↓', E:'→', W:'←' };
          const dir = (sign.params && sign.params.dir) || 'E';
          ctx.fillStyle = 'rgba(255,255,255,0.7)';
          ctx.font = 'bold 12px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(ARROWS[dir] || '→', cx, cy - TILE / 4);
          ctx.textAlign = 'left';
          ctx.textBaseline = 'alphabetic';

        } else if (sign.type === 'roundabout') {
          ctx.strokeStyle = 'rgba(100,181,246,0.8)';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.arc(cx, cy - TILE / 4, 5, 0, Math.PI * 2);
          ctx.stroke();
          ctx.lineWidth = 1;
        }
      }
    };
  })();

  // ============================================================
  // 8. ST.Effects
  // ============================================================
  ST.Effects = (function() {
    console.log('[Effects] initialized');

    let _compressor    = null;
    let _delay         = null;
    let _delayFeedback = null;
    let _delayInput    = null;
    let _reverb        = null;
    let _reverbInput   = null;
    let _sendDelay     = 0;
    let _sendReverb    = 0;
    let _preset        = 'dry';

    const PRESETS = {
      dry:   { sendDelay: 0,    sendReverb: 0   },
      room:  { sendDelay: 0,    sendReverb: 0.3 },
      echo:  { sendDelay: 0.4,  sendReverb: 0   },
      space: { sendDelay: 0.25, sendReverb: 0.5 }
    };

    function _createImpulse(ctx, dur, decay) {
      const len = Math.floor(ctx.sampleRate * dur);
      const buf = ctx.createBuffer(2, len, ctx.sampleRate);
      for (let ch = 0; ch < 2; ch++) {
        const d = buf.getChannelData(ch);
        for (let i = 0; i < len; i++) {
          d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, decay);
        }
      }
      return buf;
    }

    return {
      init: function() {
        if (_compressor) return;
        const ctx    = ST.Audio.getContext();
        const master = ST.Audio.getMasterGain();
        if (!ctx || !master) return;

        master.disconnect();
        _compressor = ctx.createDynamicsCompressor();
        _compressor.threshold.value = -24;
        _compressor.ratio.value     = 4;
        _compressor.knee.value      = 6;
        _compressor.attack.value    = 0.003;
        _compressor.release.value   = 0.25;
        master.connect(_compressor);
        _compressor.connect(ctx.destination);

        _delayInput = ctx.createGain();
        _delay = ctx.createDelay(2.0);
        _delay.delayTime.value = 60 / ST.Audio.getBPM() / 2;
        _delayFeedback = ctx.createGain();
        _delayFeedback.gain.value = 0.4;
        _delayInput.connect(_delay);
        _delay.connect(_delayFeedback);
        _delayFeedback.connect(_delay);
        _delay.connect(master);

        _reverbInput = ctx.createGain();
        _reverb = ctx.createConvolver();
        _reverb.buffer = _createImpulse(ctx, 2.0, 3);
        _reverbInput.connect(_reverb);
        _reverb.connect(master);

        console.log('[Effects] audio chain ready');
      },

      getCompressor:  function() { return _compressor; },
      getDelay:       function() { return _delay; },
      getReverb:      function() { return _reverb; },
      getDelayInput:  function() { return _delayInput; },
      getReverbInput: function() { return _reverbInput; },
      getSendDelay:   function() { return _sendDelay; },
      getSendReverb:  function() { return _sendReverb; },
      getPreset:      function() { return _preset; },

      setDelayTime: function(seconds) {
        if (_delay) _delay.delayTime.value = Math.max(0, Math.min(2, seconds));
      },

      setDelayFeedback: function(value) {
        if (_delayFeedback) _delayFeedback.gain.value = Math.max(0, Math.min(0.8, value));
      },

      setPreset: function(name) {
        const p = PRESETS[name];
        if (!p) return;
        _preset     = name;
        _sendDelay  = p.sendDelay;
        _sendReverb = p.sendReverb;
      },

      PRESETS: PRESETS
    };
  })();

  // ============================================================
  // 9. ST.Score
  // ============================================================
  ST.Score = (function() {
    console.log('[Score] initialized');

    const THRESHOLDS = [
      { min: 0,    name: 'Empty City',    decorations: 0 },
      { min: 50,   name: 'First Beat',    decorations: 1 },
      { min: 150,  name: 'Street Groove', decorations: 2 },
      { min: 300,  name: 'City Rhythm',   decorations: 3 },
      { min: 600,  name: 'Urban Pulse',   decorations: 4 },
      { min: 1000, name: 'Synth City',    decorations: 5 }
    ];

    return {
      THRESHOLDS: THRESHOLDS,

      calculate: function() {
        const buildings = ST.Buildings.getAll();
        const types     = new Set(buildings.map(function(b) { return b.type; }));
        let signCount   = 0;
        ST.Grid.forEachTile(function(tile) { if (tile.sign) signCount++; });
        return buildings.length * 10 + ST.Roads.count() * 2 +
               ST.Vehicles.count() * 15 + types.size * 20 + signCount * 10;
      },

      getThreshold: function() {
        const score = this.calculate();
        let current = THRESHOLDS[0];
        THRESHOLDS.forEach(function(t) { if (score >= t.min) current = t; });
        return current;
      }
    };
  })();

  // ============================================================
  // 10. ST.Unlocks
  // ============================================================
  ST.Unlocks = (function() {
    console.log('[Unlocks] initialized');

    const _ALWAYS = ['select','road','remove','sine','square','triangle','sawtooth','pulse','car'];
    const _GATED  = [
      { id: 'bicycle',      score: 50  },
      { id: 'trafficLight', score: 100 },
      { id: 'bus',          score: 150 },
      { id: 'oneWay',       score: 200 },
      { id: 'roundabout',   score: 300 }
    ];

    let _prevScore = 0;

    return {
      isUnlocked: function(id) {
        if (_ALWAYS.indexOf(id) !== -1) return true;
        const gated = _GATED.filter(function(g) { return g.id === id; })[0];
        if (!gated) return true;
        return ST.Score.calculate() >= gated.score;
      },

      check: function() {
        const score = ST.Score.calculate();
        const fresh = _GATED.filter(function(g) {
          return score >= g.score && _prevScore < g.score;
        });
        _prevScore = score;
        return fresh.length > 0 ? fresh.map(function(g) { return g.id; }) : null;
      },

      getAll: function() {
        const score = ST.Score.calculate();
        return _ALWAYS.concat(
          _GATED.filter(function(g) { return score >= g.score; })
                .map(function(g) { return g.id; })
        );
      }
    };
  })();

  // ============================================================
  // 11. ST.UI
  // ============================================================
  ST.UI = (function() {
    console.log('[UI] initialized');

    let _tool = 'road';
    let _selectedBuilding = null;

    const TOOL_DEFS = [
      { tool: 'select', label: 'Select',  dot: null },
      { tool: 'road',   label: 'Road',    dot: '#888' },
      { tool: 'remove', label: 'Remove',  dot: '#ef5350' }
    ];
    const BUILDING_DEFS = [
      { tool: 'sine',     label: 'Sine Wave', dot: '#64b5f6' },
      { tool: 'square',   label: 'Square',    dot: '#ef5350' },
      { tool: 'triangle', label: 'Triangle',  dot: '#66bb6a' },
      { tool: 'sawtooth', label: 'Sawtooth',  dot: '#ffa726' },
      { tool: 'pulse',    label: 'Pulse',     dot: '#ab47bc' }
    ];
    const VEHICLE_DEFS = [
      { tool: 'car',     label: 'Car',     dot: '#dce0e8' },
      { tool: 'bicycle', label: 'Bicycle', dot: '#64b5f6' },
      { tool: 'bus',     label: 'Bus',     dot: '#ffa726' }
    ];
    const SIGN_DEFS = [
      { tool: 'trafficLight', label: 'Traffic Light', dot: '#ef5350' },
      { tool: 'oneWay',       label: 'One Way',       dot: '#fff' },
      { tool: 'roundabout',   label: 'Roundabout',    dot: '#64b5f6' }
    ];

    function _buildPianoPicker(building, color) {
      const NOTES         = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
      const WHITE_IDX     = [0,2,4,5,7,9,11]; // note indices for C D E F G A B
      const BLACK_IDX     = [1,3,6,8,10];      // note indices for C# D# F# G# A#
      const BLACK_OFFSETS = [19,47,103,131,159]; // px left for each black key
      const WK = 28;

      function hzToMidi(hz) { return Math.round(12 * Math.log2(hz / 440)) + 69; }
      function midiToHz(m)  { return 440 * Math.pow(2, (m - 69) / 12); }

      const initOct = Math.max(2, Math.min(6, Math.floor(hzToMidi(building.pitch) / 12) - 1));
      const octave  = [initOct];

      const wrap = document.createElement('div');
      wrap.className = 'st-piano-wrap';

      const nav = document.createElement('div');
      nav.className = 'st-piano-nav';
      const btnPrev = document.createElement('button');
      btnPrev.className = 'st-oct-btn'; btnPrev.textContent = '‹';
      const octLabel = document.createElement('span');
      octLabel.className = 'st-piano-oct-label';
      const btnNext = document.createElement('button');
      btnNext.className = 'st-oct-btn'; btnNext.textContent = '›';
      nav.appendChild(btnPrev); nav.appendChild(octLabel); nav.appendChild(btnNext);
      wrap.appendChild(nav);

      const keysEl = document.createElement('div');
      keysEl.className = 'st-piano-keys';
      wrap.appendChild(keysEl);

      const hzEl = document.createElement('div');
      hzEl.className = 'st-props-value';

      function _updateHzEl() {
        const midi = hzToMidi(building.pitch);
        const ni   = ((midi % 12) + 12) % 12;
        const oct  = Math.floor(midi / 12) - 1;
        hzEl.textContent = NOTES[ni] + oct + '  (' + Math.round(building.pitch) + ' Hz)';
      }

      function _pickNote(midi) {
        const hz = midiToHz(midi);
        ST.Buildings.setProperty(building, 'pitch', hz);
        ST.Audio.trigger({ waveform: building.waveform, pitch: hz, decay: 0.3, velocity: 0.8 });
        _buildKeys();
        _updateHzEl();
      }

      function _buildKeys() {
        keysEl.innerHTML = '';
        const activeMidi = hzToMidi(building.pitch);

        WHITE_IDX.forEach(function(ni, i) {
          const midi = (octave[0] + 1) * 12 + ni;
          const key  = document.createElement('div');
          key.className = 'st-white-key';
          key.style.left = (i * WK) + 'px';
          if (midi === activeMidi) key.style.background = color;
          key.addEventListener('click', function(e) { e.stopPropagation(); _pickNote(midi); });
          keysEl.appendChild(key);
        });

        BLACK_IDX.forEach(function(ni, i) {
          const midi = (octave[0] + 1) * 12 + ni;
          const key  = document.createElement('div');
          key.className = 'st-black-key';
          key.style.left = BLACK_OFFSETS[i] + 'px';
          if (midi === activeMidi) { key.style.background = color; key.style.opacity = '0.85'; }
          key.addEventListener('click', function(e) { e.stopPropagation(); _pickNote(midi); });
          keysEl.appendChild(key);
        });
      }

      function _updateOctLabel() { octLabel.textContent = 'C' + octave[0]; }

      btnPrev.addEventListener('click', function() {
        octave[0] = Math.max(2, octave[0] - 1); _updateOctLabel(); _buildKeys();
      });
      btnNext.addEventListener('click', function() {
        octave[0] = Math.min(6, octave[0] + 1); _updateOctLabel(); _buildKeys();
      });

      _updateOctLabel(); _buildKeys(); _updateHzEl();
      return { pianoEl: wrap, hzEl: hzEl };
    }

    function _noteFromHz(hz) {
      const NOTES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
      const n = Math.round(12 * Math.log2(hz / 440)) + 69;
      const octave = Math.floor(n / 12) - 1;
      return NOTES[((n % 12) + 12) % 12] + octave + ' (' + Math.round(hz) + 'Hz)';
    }

    function _buildToolbar() {
      const toolbar = document.getElementById('toolbar');
      toolbar.innerHTML = '';

      function _makeSection(label) {
        const el = document.createElement('div');
        el.className = 'st-toolbar-section';
        el.textContent = label;
        toolbar.appendChild(el);
      }

      function _makeBtn(def) {
        const btn = document.createElement('button');
        btn.className = 'st-tool-btn';
        btn.dataset.tool = def.tool;
        if (!ST.Unlocks.isUnlocked(def.tool)) {
          btn.classList.add('st-locked');
          btn.title = 'Locked — raise your score to unlock';
        }
        if (def.dot) {
          const dot = document.createElement('span');
          dot.className = 'st-color-dot';
          dot.style.background = def.dot;
          btn.appendChild(dot);
        }
        btn.appendChild(document.createTextNode(def.label));
        btn.addEventListener('click', function() { ST.UI.setTool(def.tool); });
        toolbar.appendChild(btn);
      }

      _makeSection('Tools');
      TOOL_DEFS.forEach(_makeBtn);
      _makeSection('Buildings');
      BUILDING_DEFS.forEach(_makeBtn);
      _makeSection('Vehicles');
      VEHICLE_DEFS.forEach(_makeBtn);
      _makeSection('Signs');
      SIGN_DEFS.forEach(_makeBtn);

      _makeSection('Effects');
      const PRESET_LABELS = { dry: 'Dry', room: 'Room', echo: 'Echo', space: 'Space' };
      Object.keys(PRESET_LABELS).forEach(function(name) {
        const btn = document.createElement('button');
        btn.className = 'st-tool-btn';
        btn.dataset.preset = name;
        if (name === ST.Effects.getPreset()) btn.classList.add('st-active');
        btn.appendChild(document.createTextNode(PRESET_LABELS[name]));
        btn.addEventListener('click', function() {
          ST.Effects.setPreset(name);
          _updateEffectBtns();
        });
        toolbar.appendChild(btn);
      });
    }

    function _updateToolBtns() {
      document.querySelectorAll('[data-tool]').forEach(function(btn) {
        btn.classList.toggle('st-active', btn.dataset.tool === _tool);
      });
    }

    function _updateEffectBtns() {
      const preset = ST.Effects.getPreset();
      document.querySelectorAll('[data-preset]').forEach(function(btn) {
        btn.classList.toggle('st-active', btn.dataset.preset === preset);
      });
    }

    function _onCanvasAction(e) {
      const canvas = document.getElementById('game');
      const rect   = canvas.getBoundingClientRect();
      const scaleX = (ST.Config.GRID_W * ST.Config.TILE) / rect.width;
      const scaleY = (ST.Config.GRID_H * ST.Config.TILE) / rect.height;
      const gx = Math.floor((e.clientX - rect.left) * scaleX / ST.Config.TILE);
      const gy = Math.floor((e.clientY - rect.top)  * scaleY / ST.Config.TILE);
      if (!ST.Grid.isInBounds(gx, gy)) return;

      if (_tool === 'road') {
        ST.Roads.place(gx, gy);

      } else if (_tool === 'select') {
        const b = ST.Buildings.getAt(gx, gy);
        if (b) { ST.UI.showProperties(b); } else { ST.UI.hideProperties(); }

      } else if (_tool === 'remove') {
        const tile = ST.Grid.getTile(gx, gy);
        if (tile && tile.sign) {
          ST.Signs.remove(gx, gy);
        } else if (tile && tile.type === 'road') {
          ST.Roads.remove(gx, gy);
          ST.Vehicles.getAll().forEach(function(v) {
            if ((v.x === gx && v.y === gy) || (v.nextX === gx && v.nextY === gy)) {
              ST.Vehicles.remove(v);
            }
          });
        } else if (tile && tile.type === 'building') {
          if (_selectedBuilding && _selectedBuilding.x === gx && _selectedBuilding.y === gy) {
            ST.UI.hideProperties();
          }
          ST.Buildings.remove(gx, gy);
        }

      } else if (ST.Vehicles.TYPES[_tool]) {
        const tile = ST.Grid.getTile(gx, gy);
        if (tile && tile.type === 'road') ST.Vehicles.spawn(_tool, gx, gy);

      } else if (ST.Signs.TYPES[_tool]) {
        const tile = ST.Grid.getTile(gx, gy);
        if (tile && tile.type === 'road') {
          const params = _tool === 'oneWay' ? { dir: 'E' } : {};
          ST.Signs.place(_tool, gx, gy, params);
        }

      } else if (ST.Buildings.TYPES[_tool]) {
        ST.Buildings.create(_tool, gx, gy);
      }

      if (!ST.Game.isPlaying()) ST.Renderer.drawFrame();
    }

    function _setupCanvas() {
      const canvas = document.getElementById('game');
      let _mouseDown = false;

      canvas.addEventListener('mousedown', function(e) { _mouseDown = true; _onCanvasAction(e); });
      canvas.addEventListener('mousemove', function(e) {
        if (_mouseDown && (_tool === 'road' || _tool === 'remove')) _onCanvasAction(e);
      });
      canvas.addEventListener('mouseup',    function() { _mouseDown = false; });
      canvas.addEventListener('mouseleave', function() { _mouseDown = false; });
    }

    function _setupTransport() {
      const overlay    = document.getElementById('audio-overlay');
      const startBtn   = document.getElementById('btn-start-audio');
      const playBtn    = document.getElementById('btn-play');
      const bpmSlider  = document.getElementById('slider-bpm');
      const bpmDisplay = document.getElementById('bpm-display');

      if (startBtn) startBtn.addEventListener('click', function() {
        ST.Audio.init();
        ST.Effects.init();
        if (overlay) overlay.style.display = 'none';
      });
      if (playBtn) playBtn.addEventListener('click', function() {
        ST.Game.isPlaying() ? ST.Game.stop() : ST.Game.start();
      });
      if (bpmSlider) {
        bpmSlider.value = ST.Audio.getBPM();
        bpmSlider.addEventListener('input', function() {
          ST.Audio.setBPM(parseInt(this.value, 10));
          if (bpmDisplay) bpmDisplay.textContent = ST.Audio.getBPM();
        });
      }
      if (bpmDisplay) bpmDisplay.textContent = ST.Audio.getBPM();
    }

    return {
      init: function() {
        _buildToolbar();
        _setupCanvas();
        _setupTransport();
        _updateToolBtns();
      },

      setTool: function(toolName) {
        _tool = toolName;
        _updateToolBtns();
        const canvas = document.getElementById('game');
        if (canvas) canvas.style.cursor = toolName === 'select' ? 'pointer' : 'crosshair';
      },

      getTool: function() { return _tool; },

      showProperties: function(building) {
        _selectedBuilding = building;
        const panel = document.getElementById('properties');
        const app   = document.getElementById('app');
        if (!panel) return;

        const props = ST.Buildings.getProperties(building);
        panel.innerHTML = '';

        const header = document.createElement('div');
        header.className = 'st-props-header';
        const dot = document.createElement('span');
        dot.className = 'st-color-dot';
        dot.style.background = props.color;
        const title = document.createElement('span');
        title.className = 'st-props-title';
        title.textContent = building.type.charAt(0).toUpperCase() + building.type.slice(1) + ' Wave';
        const closeBtn = document.createElement('button');
        closeBtn.className = 'st-props-close';
        closeBtn.textContent = '×';
        closeBtn.addEventListener('click', function() { ST.UI.hideProperties(); });
        header.appendChild(dot);
        header.appendChild(title);
        header.appendChild(closeBtn);
        panel.appendChild(header);

        const body = document.createElement('div');
        body.className = 'st-props-body';

        function _addRow(labelText, content) {
          const row = document.createElement('div');
          row.className = 'st-props-row';
          const lbl = document.createElement('div');
          lbl.className = 'st-props-label';
          lbl.textContent = labelText;
          row.appendChild(lbl);
          row.appendChild(content);
          body.appendChild(row);
        }

        const picker = _buildPianoPicker(building, props.color);
        _addRow('Note', picker.pianoEl);
        _addRow('', picker.hzEl);

        const decayEl = document.createElement('div');
        decayEl.className = 'st-props-value';
        decayEl.textContent = props.decay + 's';
        _addRow('Decay', decayEl);

        const levelEl = document.createElement('div');
        levelEl.className = 'st-props-value';
        levelEl.textContent = 'Lv ' + props.level;
        _addRow('Level', levelEl);

        panel.appendChild(body);
        if (app) app.style.gridTemplateColumns = '200px 1fr 220px';
      },

      hideProperties: function() {
        _selectedBuilding = null;
        const panel = document.getElementById('properties');
        const app   = document.getElementById('app');
        if (panel) panel.innerHTML = '';
        if (app) app.style.gridTemplateColumns = '200px 1fr 0px';
      },

      updateTransport: function(bpm, playing) {
        const bpmDisplay = document.getElementById('bpm-display');
        const bpmSlider  = document.getElementById('slider-bpm');
        const playBtn    = document.getElementById('btn-play');
        if (bpmDisplay) bpmDisplay.textContent = bpm;
        if (bpmSlider)  bpmSlider.value = bpm;
        if (playBtn) {
          playBtn.innerHTML = playing ? '&#9646;&#9646;' : '&#9654;';
          playBtn.classList.toggle('st-active', playing);
        }
      },

      onUnlock: function(ids) {
        _buildToolbar();
        _updateToolBtns();
        const toast = document.createElement('div');
        toast.className = 'st-unlock-toast';
        toast.textContent = '🔓 Unlocked: ' + ids.join(', ');
        document.body.appendChild(toast);
        setTimeout(function() { if (toast.parentNode) toast.parentNode.removeChild(toast); }, 3100);
      }
    };
  })();

  // ============================================================
  // 13. ST.Renderer
  // ============================================================
  ST.Renderer = (function() {
    console.log('[Renderer] initialized');

    let _canvas = null;
    let _ctx = null;
    const _dirty = new Set();

    function _drawGrid() {
      const { TILE, GRID_W, GRID_H, COLORS } = ST.Config;
      _ctx.strokeStyle = COLORS.grid;
      _ctx.lineWidth = 1;
      for (let x = 0; x <= GRID_W; x++) {
        _ctx.beginPath();
        _ctx.moveTo(x * TILE + 0.5, 0);
        _ctx.lineTo(x * TILE + 0.5, GRID_H * TILE);
        _ctx.stroke();
      }
      for (let y = 0; y <= GRID_H; y++) {
        _ctx.beginPath();
        _ctx.moveTo(0, y * TILE + 0.5);
        _ctx.lineTo(GRID_W * TILE, y * TILE + 0.5);
        _ctx.stroke();
      }
    }

    return {
      init: function(canvasElement) {
        _canvas = canvasElement;
        const dpr = window.devicePixelRatio || 1;
        const W = ST.Config.GRID_W * ST.Config.TILE;
        const H = ST.Config.GRID_H * ST.Config.TILE;
        _canvas.width  = W * dpr;
        _canvas.height = H * dpr;
        _canvas.style.width  = W + 'px';
        _canvas.style.height = H + 'px';
        _ctx = _canvas.getContext('2d');
        _ctx.scale(dpr, dpr);
      },

      drawFrame: function() {
        const { GRID_W, GRID_H, TILE, COLORS } = ST.Config;
        _ctx.fillStyle = COLORS.bg;
        _ctx.fillRect(0, 0, GRID_W * TILE, GRID_H * TILE);

        ST.Grid.forEachTile(function(tile, x, y) {
          if (tile.type === 'road') ST.Roads.draw(_ctx, x, y, tile);
        });

        ST.Grid.forEachTile(function(tile, x, y) {
          if (tile.sign) ST.Signs.draw(_ctx, x, y, tile.sign);
        });

        ST.Grid.forEachTile(function(tile, x, y) {
          if (tile.type === 'building' && tile.building) ST.Buildings.draw(_ctx, tile.building);
        });

        ST.Vehicles.draw(_ctx);

        _drawGrid();
        _dirty.clear();
      },

      markDirty: function(x, y) { _dirty.add(x + ',' + y); }
    };
  })();

  // ============================================================
  // 14. ST.Game
  // ============================================================
  ST.Game = (function() {
    console.log('[Game] initialized');

    let _playing = false;
    let _rafId   = null;
    let _lastTime = 0;
    let _frameCount = 0;
    let _fpsTimer   = 0;
    let _scoreTimer = 0;

    function _loop(timestamp) {
      const dt = Math.min((timestamp - _lastTime) / 1000, 0.1);
      _lastTime = timestamp;

      if (ST.Config.DEV) {
        _frameCount++;
        _fpsTimer += dt;
        if (_fpsTimer >= 1) {
          const fps = document.getElementById('fps-display');
          if (fps) fps.textContent = _frameCount + ' fps';
          _frameCount = 0;
          _fpsTimer   = 0;
        }
      }

      _scoreTimer += dt;
      if (_scoreTimer >= 1.0) {
        _scoreTimer = 0;
        const scoreEl = document.getElementById('score-display');
        if (scoreEl) {
          const score = ST.Score.calculate();
          scoreEl.textContent = score + ' — ' + ST.Score.getThreshold().name;
        }
        const newUnlocks = ST.Unlocks.check();
        if (newUnlocks) ST.UI.onUnlock(newUnlocks);
      }

      ST.Vehicles.update(dt);
      ST.Renderer.drawFrame();

      if (_playing) _rafId = requestAnimationFrame(_loop);
    }

    return {
      init: function() {
        ST.Grid.init();
        ST.Renderer.init(document.getElementById('game'));
        ST.UI.init();
        ST.Renderer.drawFrame();
      },

      start: function() {
        if (_playing) return;
        _playing = true;
        _lastTime = performance.now();
        _rafId = requestAnimationFrame(_loop);
        ST.UI.updateTransport(ST.Audio.getBPM(), true);
      },

      stop: function() {
        if (!_playing) return;
        _playing = false;
        if (_rafId) { cancelAnimationFrame(_rafId); _rafId = null; }
        ST.Renderer.drawFrame();
        ST.UI.updateTransport(ST.Audio.getBPM(), false);
      },

      isPlaying: function() { return _playing; }
    };
  })();

  // === BOOT ===
  document.addEventListener('DOMContentLoaded', function() {
    ST.Game.init();
  });
  </script>
</body>
</html>
